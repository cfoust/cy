// Code generated by gen.go; DO NOT EDIT.
package params

import (
	"fmt"

	"github.com/cfoust/cy/pkg/janet"
	"github.com/cfoust/cy/pkg/style"
)

const (
	ParamAnimate                  = "animate"
	ParamAnimateDelay             = "animate-delay"
	ParamAnimations               = "animations"
	ParamColorError               = "color-error"
	ParamColorInfo                = "color-info"
	ParamColorMap                 = "color-map"
	ParamColorWarn                = "color-warn"
	ParamDataDirectory            = "data-directory"
	ParamDefaultFrame             = "default-frame"
	ParamDefaultShell             = "default-shell"
	ParamHistoryLimit             = "history-limit"
	ParamInputFindActiveStyle     = "input-find-active-style"
	ParamInputFindHighlightStyle  = "input-find-highlight-style"
	ParamInputFindInactiveStyle   = "input-find-inactive-style"
	ParamInputPreviewBorder       = "input-preview-border"
	ParamInputPreviewBorderFg     = "input-preview-border-fg"
	ParamInputPromptStyle         = "input-prompt-style"
	ParamInputThumbsHintStyle     = "input-thumbs-hint-style"
	ParamInputThumbsMatchStyle    = "input-thumbs-match-style"
	ParamInputThumbsPartialStyle  = "input-thumbs-partial-style"
	ParamNumSearchWorkers         = "num-search-workers"
	ParamRemovePaneOnExit         = "remove-pane-on-exit"
	ParamReplayCopyStyle          = "replay-copy-style"
	ParamReplayIncrementalStyle   = "replay-incremental-style"
	ParamReplayMatchActiveStyle   = "replay-match-active-style"
	ParamReplayMatchInactiveStyle = "replay-match-inactive-style"
	ParamReplayPlayStyle          = "replay-play-style"
	ParamReplaySelectionStyle     = "replay-selection-style"
	ParamReplayStatusBarStyle     = "replay-status-bar-style"
	ParamReplayTextCopyMode       = "replay-text-copy-mode"
	ParamReplayTextPlayMode       = "replay-text-play-mode"
	ParamReplayTextTimeMode       = "replay-text-time-mode"
	ParamReplayTextVisualMode     = "replay-text-visual-mode"
	ParamReplayTimeStyle          = "replay-time-style"
	ParamReplayVisualStyle        = "replay-visual-style"
	ParamSearchStatusBarStyle     = "search-status-bar-style"
	ParamSearchTextNoMatchesFound = "search-text-no-matches-found"
	ParamSearchTextSearching      = "search-text-searching"
	ParamSkipInput                = "---skip-input"
	ParamTerminalTextExited       = "terminal-text-exited"
	ParamTimestampFormat          = "timestamp-format"
	ParamUseSystemClipboard       = "use-system-clipboard"
)

func (p *Parameters) Animate() bool {
	value, ok := p.Get(ParamAnimate)
	if !ok {
		return defaults.Animate
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.Animate
	}

	return realValue
}

func (p *Parameters) SetAnimate(value bool) {
	p.set(ParamAnimate, value)
}

func (p *Parameters) AnimateDelay() int {
	value, ok := p.Get(ParamAnimateDelay)
	if !ok {
		return defaults.AnimateDelay
	}

	realValue, ok := value.(int)
	if !ok {
		return defaults.AnimateDelay
	}

	return realValue
}

func (p *Parameters) SetAnimateDelay(value int) {
	p.set(ParamAnimateDelay, value)
}

func (p *Parameters) Animations() []string {
	value, ok := p.Get(ParamAnimations)
	if !ok {
		return defaults.Animations
	}

	realValue, ok := value.([]string)
	if !ok {
		return defaults.Animations
	}

	return realValue
}

func (p *Parameters) SetAnimations(value []string) {
	p.set(ParamAnimations, value)
}

func (p *Parameters) ColorError() *style.Color {
	value, ok := p.Get(ParamColorError)
	if !ok {
		return defaults.ColorError
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ColorError
	}

	return realValue
}

func (p *Parameters) SetColorError(value *style.Color) {
	p.set(ParamColorError, value)
}

func (p *Parameters) ColorInfo() *style.Color {
	value, ok := p.Get(ParamColorInfo)
	if !ok {
		return defaults.ColorInfo
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ColorInfo
	}

	return realValue
}

func (p *Parameters) SetColorInfo(value *style.Color) {
	p.set(ParamColorInfo, value)
}

func (p *Parameters) ColorMap() *style.ColorMap {
	value, ok := p.Get(ParamColorMap)
	if !ok {
		return defaults.ColorMap
	}

	realValue, ok := value.(*style.ColorMap)
	if !ok {
		return defaults.ColorMap
	}

	return realValue
}

func (p *Parameters) SetColorMap(value *style.ColorMap) {
	p.set(ParamColorMap, value)
}

func (p *Parameters) ColorWarn() *style.Color {
	value, ok := p.Get(ParamColorWarn)
	if !ok {
		return defaults.ColorWarn
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ColorWarn
	}

	return realValue
}

func (p *Parameters) SetColorWarn(value *style.Color) {
	p.set(ParamColorWarn, value)
}

func (p *Parameters) DataDirectory() string {
	value, ok := p.Get(ParamDataDirectory)
	if !ok {
		return defaults.DataDirectory
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.DataDirectory
	}

	return realValue
}

func (p *Parameters) SetDataDirectory(value string) {
	p.set(ParamDataDirectory, value)
}

func (p *Parameters) DefaultFrame() string {
	value, ok := p.Get(ParamDefaultFrame)
	if !ok {
		return defaults.DefaultFrame
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.DefaultFrame
	}

	return realValue
}

func (p *Parameters) SetDefaultFrame(value string) {
	p.set(ParamDefaultFrame, value)
}

func (p *Parameters) DefaultShell() string {
	value, ok := p.Get(ParamDefaultShell)
	if !ok {
		return defaults.DefaultShell
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.DefaultShell
	}

	return realValue
}

func (p *Parameters) SetDefaultShell(value string) {
	p.set(ParamDefaultShell, value)
}

func (p *Parameters) HistoryLimit() int {
	value, ok := p.Get(ParamHistoryLimit)
	if !ok {
		return defaults.HistoryLimit
	}

	realValue, ok := value.(int)
	if !ok {
		return defaults.HistoryLimit
	}

	return realValue
}

func (p *Parameters) SetHistoryLimit(value int) {
	p.set(ParamHistoryLimit, value)
}

func (p *Parameters) InputFindActiveStyle() *style.Style {
	value, ok := p.Get(ParamInputFindActiveStyle)
	if !ok {
		return defaults.InputFindActiveStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.InputFindActiveStyle
	}

	return realValue
}

func (p *Parameters) SetInputFindActiveStyle(value *style.Style) {
	p.set(ParamInputFindActiveStyle, value)
}

func (p *Parameters) InputFindHighlightStyle() *style.Style {
	value, ok := p.Get(ParamInputFindHighlightStyle)
	if !ok {
		return defaults.InputFindHighlightStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.InputFindHighlightStyle
	}

	return realValue
}

func (p *Parameters) SetInputFindHighlightStyle(value *style.Style) {
	p.set(ParamInputFindHighlightStyle, value)
}

func (p *Parameters) InputFindInactiveStyle() *style.Style {
	value, ok := p.Get(ParamInputFindInactiveStyle)
	if !ok {
		return defaults.InputFindInactiveStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.InputFindInactiveStyle
	}

	return realValue
}

func (p *Parameters) SetInputFindInactiveStyle(value *style.Style) {
	p.set(ParamInputFindInactiveStyle, value)
}

func (p *Parameters) InputPreviewBorder() *style.Border {
	value, ok := p.Get(ParamInputPreviewBorder)
	if !ok {
		return defaults.InputPreviewBorder
	}

	realValue, ok := value.(*style.Border)
	if !ok {
		return defaults.InputPreviewBorder
	}

	return realValue
}

func (p *Parameters) SetInputPreviewBorder(value *style.Border) {
	p.set(ParamInputPreviewBorder, value)
}

func (p *Parameters) InputPreviewBorderFg() *style.Color {
	value, ok := p.Get(ParamInputPreviewBorderFg)
	if !ok {
		return defaults.InputPreviewBorderFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputPreviewBorderFg
	}

	return realValue
}

func (p *Parameters) SetInputPreviewBorderFg(value *style.Color) {
	p.set(ParamInputPreviewBorderFg, value)
}

func (p *Parameters) InputPromptStyle() *style.Style {
	value, ok := p.Get(ParamInputPromptStyle)
	if !ok {
		return defaults.InputPromptStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.InputPromptStyle
	}

	return realValue
}

func (p *Parameters) SetInputPromptStyle(value *style.Style) {
	p.set(ParamInputPromptStyle, value)
}

func (p *Parameters) InputThumbsHintStyle() *style.Style {
	value, ok := p.Get(ParamInputThumbsHintStyle)
	if !ok {
		return defaults.InputThumbsHintStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.InputThumbsHintStyle
	}

	return realValue
}

func (p *Parameters) SetInputThumbsHintStyle(value *style.Style) {
	p.set(ParamInputThumbsHintStyle, value)
}

func (p *Parameters) InputThumbsMatchStyle() *style.Style {
	value, ok := p.Get(ParamInputThumbsMatchStyle)
	if !ok {
		return defaults.InputThumbsMatchStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.InputThumbsMatchStyle
	}

	return realValue
}

func (p *Parameters) SetInputThumbsMatchStyle(value *style.Style) {
	p.set(ParamInputThumbsMatchStyle, value)
}

func (p *Parameters) InputThumbsPartialStyle() *style.Style {
	value, ok := p.Get(ParamInputThumbsPartialStyle)
	if !ok {
		return defaults.InputThumbsPartialStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.InputThumbsPartialStyle
	}

	return realValue
}

func (p *Parameters) SetInputThumbsPartialStyle(value *style.Style) {
	p.set(ParamInputThumbsPartialStyle, value)
}

func (p *Parameters) NumSearchWorkers() int {
	value, ok := p.Get(ParamNumSearchWorkers)
	if !ok {
		return defaults.NumSearchWorkers
	}

	realValue, ok := value.(int)
	if !ok {
		return defaults.NumSearchWorkers
	}

	return realValue
}

func (p *Parameters) SetNumSearchWorkers(value int) {
	p.set(ParamNumSearchWorkers, value)
}

func (p *Parameters) RemovePaneOnExit() bool {
	value, ok := p.Get(ParamRemovePaneOnExit)
	if !ok {
		return defaults.RemovePaneOnExit
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.RemovePaneOnExit
	}

	return realValue
}

func (p *Parameters) SetRemovePaneOnExit(value bool) {
	p.set(ParamRemovePaneOnExit, value)
}

func (p *Parameters) ReplayCopyStyle() *style.Style {
	value, ok := p.Get(ParamReplayCopyStyle)
	if !ok {
		return defaults.ReplayCopyStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayCopyStyle
	}

	return realValue
}

func (p *Parameters) SetReplayCopyStyle(value *style.Style) {
	p.set(ParamReplayCopyStyle, value)
}

func (p *Parameters) ReplayIncrementalStyle() *style.Style {
	value, ok := p.Get(ParamReplayIncrementalStyle)
	if !ok {
		return defaults.ReplayIncrementalStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayIncrementalStyle
	}

	return realValue
}

func (p *Parameters) SetReplayIncrementalStyle(value *style.Style) {
	p.set(ParamReplayIncrementalStyle, value)
}

func (p *Parameters) ReplayMatchActiveStyle() *style.Style {
	value, ok := p.Get(ParamReplayMatchActiveStyle)
	if !ok {
		return defaults.ReplayMatchActiveStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayMatchActiveStyle
	}

	return realValue
}

func (p *Parameters) SetReplayMatchActiveStyle(value *style.Style) {
	p.set(ParamReplayMatchActiveStyle, value)
}

func (p *Parameters) ReplayMatchInactiveStyle() *style.Style {
	value, ok := p.Get(ParamReplayMatchInactiveStyle)
	if !ok {
		return defaults.ReplayMatchInactiveStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayMatchInactiveStyle
	}

	return realValue
}

func (p *Parameters) SetReplayMatchInactiveStyle(value *style.Style) {
	p.set(ParamReplayMatchInactiveStyle, value)
}

func (p *Parameters) ReplayPlayStyle() *style.Style {
	value, ok := p.Get(ParamReplayPlayStyle)
	if !ok {
		return defaults.ReplayPlayStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayPlayStyle
	}

	return realValue
}

func (p *Parameters) SetReplayPlayStyle(value *style.Style) {
	p.set(ParamReplayPlayStyle, value)
}

func (p *Parameters) ReplaySelectionStyle() *style.Style {
	value, ok := p.Get(ParamReplaySelectionStyle)
	if !ok {
		return defaults.ReplaySelectionStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplaySelectionStyle
	}

	return realValue
}

func (p *Parameters) SetReplaySelectionStyle(value *style.Style) {
	p.set(ParamReplaySelectionStyle, value)
}

func (p *Parameters) ReplayStatusBarStyle() *style.Style {
	value, ok := p.Get(ParamReplayStatusBarStyle)
	if !ok {
		return defaults.ReplayStatusBarStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayStatusBarStyle
	}

	return realValue
}

func (p *Parameters) SetReplayStatusBarStyle(value *style.Style) {
	p.set(ParamReplayStatusBarStyle, value)
}

func (p *Parameters) ReplayTextCopyMode() string {
	value, ok := p.Get(ParamReplayTextCopyMode)
	if !ok {
		return defaults.ReplayTextCopyMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextCopyMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextCopyMode(value string) {
	p.set(ParamReplayTextCopyMode, value)
}

func (p *Parameters) ReplayTextPlayMode() string {
	value, ok := p.Get(ParamReplayTextPlayMode)
	if !ok {
		return defaults.ReplayTextPlayMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextPlayMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextPlayMode(value string) {
	p.set(ParamReplayTextPlayMode, value)
}

func (p *Parameters) ReplayTextTimeMode() string {
	value, ok := p.Get(ParamReplayTextTimeMode)
	if !ok {
		return defaults.ReplayTextTimeMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextTimeMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextTimeMode(value string) {
	p.set(ParamReplayTextTimeMode, value)
}

func (p *Parameters) ReplayTextVisualMode() string {
	value, ok := p.Get(ParamReplayTextVisualMode)
	if !ok {
		return defaults.ReplayTextVisualMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextVisualMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextVisualMode(value string) {
	p.set(ParamReplayTextVisualMode, value)
}

func (p *Parameters) ReplayTimeStyle() *style.Style {
	value, ok := p.Get(ParamReplayTimeStyle)
	if !ok {
		return defaults.ReplayTimeStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayTimeStyle
	}

	return realValue
}

func (p *Parameters) SetReplayTimeStyle(value *style.Style) {
	p.set(ParamReplayTimeStyle, value)
}

func (p *Parameters) ReplayVisualStyle() *style.Style {
	value, ok := p.Get(ParamReplayVisualStyle)
	if !ok {
		return defaults.ReplayVisualStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.ReplayVisualStyle
	}

	return realValue
}

func (p *Parameters) SetReplayVisualStyle(value *style.Style) {
	p.set(ParamReplayVisualStyle, value)
}

func (p *Parameters) SearchStatusBarStyle() *style.Style {
	value, ok := p.Get(ParamSearchStatusBarStyle)
	if !ok {
		return defaults.SearchStatusBarStyle
	}

	realValue, ok := value.(*style.Style)
	if !ok {
		return defaults.SearchStatusBarStyle
	}

	return realValue
}

func (p *Parameters) SetSearchStatusBarStyle(value *style.Style) {
	p.set(ParamSearchStatusBarStyle, value)
}

func (p *Parameters) SearchTextNoMatchesFound() string {
	value, ok := p.Get(ParamSearchTextNoMatchesFound)
	if !ok {
		return defaults.SearchTextNoMatchesFound
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.SearchTextNoMatchesFound
	}

	return realValue
}

func (p *Parameters) SetSearchTextNoMatchesFound(value string) {
	p.set(ParamSearchTextNoMatchesFound, value)
}

func (p *Parameters) SearchTextSearching() string {
	value, ok := p.Get(ParamSearchTextSearching)
	if !ok {
		return defaults.SearchTextSearching
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.SearchTextSearching
	}

	return realValue
}

func (p *Parameters) SetSearchTextSearching(value string) {
	p.set(ParamSearchTextSearching, value)
}

func (p *Parameters) SkipInput() bool {
	value, ok := p.Get(ParamSkipInput)
	if !ok {
		return defaults.skipInput
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.skipInput
	}

	return realValue
}

func (p *Parameters) SetSkipInput(value bool) {
	p.set(ParamSkipInput, value)
}

func (p *Parameters) TerminalTextExited() string {
	value, ok := p.Get(ParamTerminalTextExited)
	if !ok {
		return defaults.TerminalTextExited
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.TerminalTextExited
	}

	return realValue
}

func (p *Parameters) SetTerminalTextExited(value string) {
	p.set(ParamTerminalTextExited, value)
}

func (p *Parameters) TimestampFormat() string {
	value, ok := p.Get(ParamTimestampFormat)
	if !ok {
		return defaults.TimestampFormat
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.TimestampFormat
	}

	return realValue
}

func (p *Parameters) SetTimestampFormat(value string) {
	p.set(ParamTimestampFormat, value)
}

func (p *Parameters) UseSystemClipboard() bool {
	value, ok := p.Get(ParamUseSystemClipboard)
	if !ok {
		return defaults.UseSystemClipboard
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.UseSystemClipboard
	}

	return realValue
}

func (p *Parameters) SetUseSystemClipboard(value bool) {
	p.set(ParamUseSystemClipboard, value)
}

func (p *Parameters) isDefault(key string) bool {
	switch key {
	case ParamAnimate:
		return true
	case ParamAnimateDelay:
		return true
	case ParamAnimations:
		return true
	case ParamColorError:
		return true
	case ParamColorInfo:
		return true
	case ParamColorMap:
		return true
	case ParamColorWarn:
		return true
	case ParamDataDirectory:
		return true
	case ParamDefaultFrame:
		return true
	case ParamDefaultShell:
		return true
	case ParamHistoryLimit:
		return true
	case ParamInputFindActiveStyle:
		return true
	case ParamInputFindHighlightStyle:
		return true
	case ParamInputFindInactiveStyle:
		return true
	case ParamInputPreviewBorder:
		return true
	case ParamInputPreviewBorderFg:
		return true
	case ParamInputPromptStyle:
		return true
	case ParamInputThumbsHintStyle:
		return true
	case ParamInputThumbsMatchStyle:
		return true
	case ParamInputThumbsPartialStyle:
		return true
	case ParamNumSearchWorkers:
		return true
	case ParamRemovePaneOnExit:
		return true
	case ParamReplayCopyStyle:
		return true
	case ParamReplayIncrementalStyle:
		return true
	case ParamReplayMatchActiveStyle:
		return true
	case ParamReplayMatchInactiveStyle:
		return true
	case ParamReplayPlayStyle:
		return true
	case ParamReplaySelectionStyle:
		return true
	case ParamReplayStatusBarStyle:
		return true
	case ParamReplayTextCopyMode:
		return true
	case ParamReplayTextPlayMode:
		return true
	case ParamReplayTextTimeMode:
		return true
	case ParamReplayTextVisualMode:
		return true
	case ParamReplayTimeStyle:
		return true
	case ParamReplayVisualStyle:
		return true
	case ParamSearchStatusBarStyle:
		return true
	case ParamSearchTextNoMatchesFound:
		return true
	case ParamSearchTextSearching:
		return true
	case ParamSkipInput:
		return true
	case ParamTerminalTextExited:
		return true
	case ParamTimestampFormat:
		return true
	case ParamUseSystemClipboard:
		return true

	}
	return false
}

func (p *Parameters) getDefault(key string) (value interface{}, ok bool) {
	switch key {
	case ParamAnimate:
		return defaults.Animate, true
	case ParamAnimateDelay:
		return defaults.AnimateDelay, true
	case ParamAnimations:
		return defaults.Animations, true
	case ParamColorError:
		return defaults.ColorError, true
	case ParamColorInfo:
		return defaults.ColorInfo, true
	case ParamColorMap:
		return defaults.ColorMap, true
	case ParamColorWarn:
		return defaults.ColorWarn, true
	case ParamDataDirectory:
		return defaults.DataDirectory, true
	case ParamDefaultFrame:
		return defaults.DefaultFrame, true
	case ParamDefaultShell:
		return defaults.DefaultShell, true
	case ParamHistoryLimit:
		return defaults.HistoryLimit, true
	case ParamInputFindActiveStyle:
		return defaults.InputFindActiveStyle, true
	case ParamInputFindHighlightStyle:
		return defaults.InputFindHighlightStyle, true
	case ParamInputFindInactiveStyle:
		return defaults.InputFindInactiveStyle, true
	case ParamInputPreviewBorder:
		return defaults.InputPreviewBorder, true
	case ParamInputPreviewBorderFg:
		return defaults.InputPreviewBorderFg, true
	case ParamInputPromptStyle:
		return defaults.InputPromptStyle, true
	case ParamInputThumbsHintStyle:
		return defaults.InputThumbsHintStyle, true
	case ParamInputThumbsMatchStyle:
		return defaults.InputThumbsMatchStyle, true
	case ParamInputThumbsPartialStyle:
		return defaults.InputThumbsPartialStyle, true
	case ParamNumSearchWorkers:
		return defaults.NumSearchWorkers, true
	case ParamRemovePaneOnExit:
		return defaults.RemovePaneOnExit, true
	case ParamReplayCopyStyle:
		return defaults.ReplayCopyStyle, true
	case ParamReplayIncrementalStyle:
		return defaults.ReplayIncrementalStyle, true
	case ParamReplayMatchActiveStyle:
		return defaults.ReplayMatchActiveStyle, true
	case ParamReplayMatchInactiveStyle:
		return defaults.ReplayMatchInactiveStyle, true
	case ParamReplayPlayStyle:
		return defaults.ReplayPlayStyle, true
	case ParamReplaySelectionStyle:
		return defaults.ReplaySelectionStyle, true
	case ParamReplayStatusBarStyle:
		return defaults.ReplayStatusBarStyle, true
	case ParamReplayTextCopyMode:
		return defaults.ReplayTextCopyMode, true
	case ParamReplayTextPlayMode:
		return defaults.ReplayTextPlayMode, true
	case ParamReplayTextTimeMode:
		return defaults.ReplayTextTimeMode, true
	case ParamReplayTextVisualMode:
		return defaults.ReplayTextVisualMode, true
	case ParamReplayTimeStyle:
		return defaults.ReplayTimeStyle, true
	case ParamReplayVisualStyle:
		return defaults.ReplayVisualStyle, true
	case ParamSearchStatusBarStyle:
		return defaults.SearchStatusBarStyle, true
	case ParamSearchTextNoMatchesFound:
		return defaults.SearchTextNoMatchesFound, true
	case ParamSearchTextSearching:
		return defaults.SearchTextSearching, true
	case ParamSkipInput:
		return defaults.skipInput, true
	case ParamTerminalTextExited:
		return defaults.TerminalTextExited, true
	case ParamTimestampFormat:
		return defaults.TimestampFormat, true
	case ParamUseSystemClipboard:
		return defaults.UseSystemClipboard, true

	}
	return nil, false
}

func (p *Parameters) setDefault(key string, value interface{}) error {
	janetValue, janetOk := value.(*janet.Value)
	switch key {
	case ParamAnimate:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamAnimate, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		var translated bool
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :animate: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamAnimateDelay:
		if !janetOk {
			realValue, ok := value.(int)
			if !ok {
				return fmt.Errorf("invalid value for ParamAnimateDelay, should be int")
			}
			p.set(key, realValue)
			return nil
		}

		var translated int
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :animate-delay: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamAnimations:
		if !janetOk {
			realValue, ok := value.([]string)
			if !ok {
				return fmt.Errorf("invalid value for ParamAnimations, should be []string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated []string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :animations: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorError:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorError, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-error: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorInfo:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorInfo, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-info: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorMap:
		if !janetOk {
			realValue, ok := value.(*style.ColorMap)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorMap, should be *style.ColorMap")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.ColorMap
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-map: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorWarn:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorWarn, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-warn: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamDataDirectory:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamDataDirectory, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :data-directory: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamDefaultFrame:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamDefaultFrame, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :default-frame: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamDefaultShell:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamDefaultShell, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :default-shell: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamHistoryLimit:
		if !janetOk {
			realValue, ok := value.(int)
			if !ok {
				return fmt.Errorf("invalid value for ParamHistoryLimit, should be int")
			}
			p.set(key, realValue)
			return nil
		}

		var translated int
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :history-limit: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindActiveStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindActiveStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-active-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindHighlightStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindHighlightStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-highlight-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindInactiveStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindInactiveStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-inactive-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputPreviewBorder:
		if !janetOk {
			realValue, ok := value.(*style.Border)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputPreviewBorder, should be *style.Border")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Border
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-preview-border: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputPreviewBorderFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputPreviewBorderFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-preview-border-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputPromptStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputPromptStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-prompt-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsHintStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsHintStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-hint-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsMatchStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsMatchStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-match-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsPartialStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsPartialStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-partial-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamNumSearchWorkers:
		if !janetOk {
			realValue, ok := value.(int)
			if !ok {
				return fmt.Errorf("invalid value for ParamNumSearchWorkers, should be int")
			}
			p.set(key, realValue)
			return nil
		}

		var translated int
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :num-search-workers: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamRemovePaneOnExit:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamRemovePaneOnExit, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		var translated bool
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :remove-pane-on-exit: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayCopyStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayCopyStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-copy-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayIncrementalStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayIncrementalStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-incremental-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayMatchActiveStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayMatchActiveStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-match-active-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayMatchInactiveStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayMatchInactiveStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-match-inactive-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayPlayStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayPlayStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-play-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplaySelectionStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplaySelectionStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-selection-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayStatusBarStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayStatusBarStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-status-bar-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextCopyMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextCopyMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-copy-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextPlayMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextPlayMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-play-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextTimeMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextTimeMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-time-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextVisualMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextVisualMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-visual-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTimeStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTimeStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-time-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayVisualStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayVisualStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-visual-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSearchStatusBarStyle:
		if !janetOk {
			realValue, ok := value.(*style.Style)
			if !ok {
				return fmt.Errorf("invalid value for ParamSearchStatusBarStyle, should be *style.Style")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Style
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :search-status-bar-style: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSearchTextNoMatchesFound:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamSearchTextNoMatchesFound, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :search-text-no-matches-found: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSearchTextSearching:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamSearchTextSearching, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :search-text-searching: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSkipInput:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamSkipInput, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		return fmt.Errorf(":---skip-input is a protected parameter")

	case ParamTerminalTextExited:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamTerminalTextExited, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :terminal-text-exited: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamTimestampFormat:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamTimestampFormat, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :timestamp-format: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamUseSystemClipboard:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamUseSystemClipboard, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		var translated bool
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :use-system-clipboard: %s", err)
		}
		p.set(key, translated)
		return nil

	}
	return nil
}

func init() {
	_defaultParams = []DefaultParam{
		{
			Name:      "animate",
			Docstring: "Whether to enable animation.",
			Default:   defaults.Animate,
		},
		{
			Name:      "animate-delay",
			Docstring: "The delay (in seconds) before animations should begin. This is useful\nif you like cy's animations but find them distracting when working\nquickly. This only applies to the animations that play when using the\n(input/*) family of functions.",
			Default:   defaults.AnimateDelay,
		},
		{
			Name:      "animations",
			Docstring: "A list of all of the enabled animations that will be used by\n(input/find). If this is an empty array, all built-in animations\nwill be enabled.",
			Default:   defaults.Animations,
		},
		{
			Name:      "color-error",
			Docstring: "The [color](/api.md#color) used for error messages.",
			Default:   defaults.ColorError,
		},
		{
			Name:      "color-info",
			Docstring: "The [color](/api.md#color) used for info messages.",
			Default:   defaults.ColorInfo,
		},
		{
			Name:      "color-map",
			Docstring: "The [color map](/api.md#color-map) used to translate the colors\nused for rendering a pane.",
			Default:   defaults.ColorMap,
		},
		{
			Name:      "color-warn",
			Docstring: "The [color](/api.md#color) used for warning messages.",
			Default:   defaults.ColorWarn,
		},
		{
			Name:      "data-directory",
			Docstring: "The directory in which .borg files will be saved. This is [inferred\non startup](/replay-mode.md#recording-to-disk). If\nset to an empty string, recording to disk is disabled.",
			Default:   defaults.DataDirectory,
		},
		{
			Name:      "default-frame",
			Docstring: "The frame used for all new clients. A blank string means a random\nframe will be chosen from all frames.",
			Default:   defaults.DefaultFrame,
		},
		{
			Name:      "default-shell",
			Docstring: "The default shell with which to start panes. Defaults to the value\nof `$SHELL` on startup.",
			Default:   defaults.DefaultShell,
		},
		{
			Name:      "history-limit",
			Docstring: "The maximum number of physical lines kept in memory for a pane's\nscrollback buffer. When recording to disk, this is the amount of\nscrollback available in copy mode before cy loads the full history from\nthe .borg file. A non-positive value disables pruning.",
			Default:   defaults.HistoryLimit,
		},
		{
			Name:      "input-find-active-style",
			Docstring: "The [style](/api.md#style) of the active row in (input/find).",
			Default:   defaults.InputFindActiveStyle,
		},
		{
			Name:      "input-find-highlight-style",
			Docstring: "The [style](/api.md#style) of highlighted characters in (input/find).",
			Default:   defaults.InputFindHighlightStyle,
		},
		{
			Name:      "input-find-inactive-style",
			Docstring: "The [style](/api.md#style) of the inactive row in (input/find).",
			Default:   defaults.InputFindInactiveStyle,
		},
		{
			Name:      "input-preview-border",
			Docstring: "The border style of the preview border in (input/find).",
			Default:   defaults.InputPreviewBorder,
		},
		{
			Name:      "input-preview-border-fg",
			Docstring: "The [color](/api.md#color) of the preview border in (input/find).",
			Default:   defaults.InputPreviewBorderFg,
		},
		{
			Name:      "input-prompt-style",
			Docstring: "The [style](/api.md#style) of the input prompt in\n(input/*) functions.",
			Default:   defaults.InputPromptStyle,
		},
		{
			Name:      "input-thumbs-hint-style",
			Docstring: "The [style](/api.md#style) of hint text in (input/thumbs).",
			Default:   defaults.InputThumbsHintStyle,
		},
		{
			Name:      "input-thumbs-match-style",
			Docstring: "The [style](/api.md#style) of match text in (input/thumbs).",
			Default:   defaults.InputThumbsMatchStyle,
		},
		{
			Name:      "input-thumbs-partial-style",
			Docstring: "The [style](/api.md#style) of partially selected hint text in (input/thumbs).",
			Default:   defaults.InputThumbsPartialStyle,
		},
		{
			Name:      "num-search-workers",
			Docstring: "The number of goroutines to use for searching in .borg files.\nDefaults to the number of CPUs.",
			Default:   defaults.NumSearchWorkers,
		},
		{
			Name:      "remove-pane-on-exit",
			Docstring: "If this is `true`, when a pane's process exits or its node is killed\n(such as with {{api tree/rm}}), the portion of the layout related\nto that node will be removed. This makes cy's layout functionality\nwork a bit more like tmux.",
			Default:   defaults.RemovePaneOnExit,
		},
		{
			Name:      "replay-copy-style",
			Docstring: "The [style](/api.md#style) used to represent copy mode.",
			Default:   defaults.ReplayCopyStyle,
		},
		{
			Name:      "replay-incremental-style",
			Docstring: "The [style](/api.md#style) for incremental search in replay mode.",
			Default:   defaults.ReplayIncrementalStyle,
		},
		{
			Name:      "replay-match-active-style",
			Docstring: "The [style](/api.md#style) for the current search match in replay mode.",
			Default:   defaults.ReplayMatchActiveStyle,
		},
		{
			Name:      "replay-match-inactive-style",
			Docstring: "The [style](/api.md#style) for search matches in replay mode.",
			Default:   defaults.ReplayMatchInactiveStyle,
		},
		{
			Name:      "replay-play-style",
			Docstring: "The [style](/api.md#style) used in time mode when the player is playing.",
			Default:   defaults.ReplayPlayStyle,
		},
		{
			Name:      "replay-selection-style",
			Docstring: "The [style](/api.md#style) for selections in replay mode.",
			Default:   defaults.ReplaySelectionStyle,
		},
		{
			Name:      "replay-status-bar-style",
			Docstring: "The [style](/api.md#style) of the status bar in replay mode.",
			Default:   defaults.ReplayStatusBarStyle,
		},
		{
			Name:      "replay-text-copy-mode",
			Docstring: "The text shown in the status bar when in copy mode.",
			Default:   defaults.ReplayTextCopyMode,
		},
		{
			Name:      "replay-text-play-mode",
			Docstring: "The text shown in the status bar when playing.",
			Default:   defaults.ReplayTextPlayMode,
		},
		{
			Name:      "replay-text-time-mode",
			Docstring: "The text shown in the status bar when in time mode.",
			Default:   defaults.ReplayTextTimeMode,
		},
		{
			Name:      "replay-text-visual-mode",
			Docstring: "The text shown in the status bar when in visual mode.",
			Default:   defaults.ReplayTextVisualMode,
		},
		{
			Name:      "replay-time-style",
			Docstring: "The [style](/api.md#style) used to represent time mode.",
			Default:   defaults.ReplayTimeStyle,
		},
		{
			Name:      "replay-visual-style",
			Docstring: "The [style](/api.md#style) used to represent visual mode.",
			Default:   defaults.ReplayVisualStyle,
		},
		{
			Name:      "search-status-bar-style",
			Docstring: "The [style](/api.md#style) of the status bar in search mode.",
			Default:   defaults.SearchStatusBarStyle,
		},
		{
			Name:      "search-text-no-matches-found",
			Docstring: "The text shown in the status bar when no matches are found.",
			Default:   defaults.SearchTextNoMatchesFound,
		},
		{
			Name:      "search-text-searching",
			Docstring: "The text shown in the status bar when searching.",
			Default:   defaults.SearchTextSearching,
		},
		{
			Name:      "terminal-text-exited",
			Docstring: "The text shown when a terminal session exits.",
			Default:   defaults.TerminalTextExited,
		},
		{
			Name:      "timestamp-format",
			Docstring: "The format for all timestamps shown in cy. This uses Go's\ntime.Layout format described\n[here](https://pkg.go.dev/time#Layout).",
			Default:   defaults.TimestampFormat,
		},
		{
			Name:      "use-system-clipboard",
			Docstring: "Whether to use the system clipboard instead of outputting OSC-52\ncodes. This should generally be \"true\" unless you use an old terminal\nemulator.",
			Default:   defaults.UseSystemClipboard,
		},
	}
}
