// Code generated by gen.go; DO NOT EDIT.
package params

import (
	"fmt"

	"github.com/cfoust/cy/pkg/janet"
	"github.com/cfoust/cy/pkg/style"
)

const (
	ParamAnimate                  = "animate"
	ParamAnimations               = "animations"
	ParamColorError               = "color-error"
	ParamColorInfo                = "color-info"
	ParamColorMap                 = "color-map"
	ParamColorWarn                = "color-warn"
	ParamDataDirectory            = "data-directory"
	ParamDefaultFrame             = "default-frame"
	ParamDefaultShell             = "default-shell"
	ParamInputFindActiveBg        = "input-find-active-bg"
	ParamInputFindActiveFg        = "input-find-active-fg"
	ParamInputFindHighlightBg     = "input-find-highlight-bg"
	ParamInputFindHighlightFg     = "input-find-highlight-fg"
	ParamInputFindInactiveBg      = "input-find-inactive-bg"
	ParamInputFindInactiveFg      = "input-find-inactive-fg"
	ParamInputPreviewBorder       = "input-preview-border"
	ParamInputPreviewBorderFg     = "input-preview-border-fg"
	ParamInputPromptBg            = "input-prompt-bg"
	ParamInputPromptFg            = "input-prompt-fg"
	ParamInputThumbsHintBg        = "input-thumbs-hint-bg"
	ParamInputThumbsHintFg        = "input-thumbs-hint-fg"
	ParamInputThumbsMatchBg       = "input-thumbs-match-bg"
	ParamInputThumbsMatchFg       = "input-thumbs-match-fg"
	ParamInputThumbsPartialBg     = "input-thumbs-partial-bg"
	ParamInputThumbsPartialFg     = "input-thumbs-partial-fg"
	ParamNumSearchWorkers         = "num-search-workers"
	ParamRemovePaneOnExit         = "remove-pane-on-exit"
	ParamReplayCopyBg             = "replay-copy-bg"
	ParamReplayCopyFg             = "replay-copy-fg"
	ParamReplayIncrementalBg      = "replay-incremental-bg"
	ParamReplayIncrementalFg      = "replay-incremental-fg"
	ParamReplayMatchActiveBg      = "replay-match-active-bg"
	ParamReplayMatchActiveFg      = "replay-match-active-fg"
	ParamReplayMatchInactiveBg    = "replay-match-inactive-bg"
	ParamReplayMatchInactiveFg    = "replay-match-inactive-fg"
	ParamReplayPlayBg             = "replay-play-bg"
	ParamReplayPlayFg             = "replay-play-fg"
	ParamReplaySelectionBg        = "replay-selection-bg"
	ParamReplaySelectionFg        = "replay-selection-fg"
	ParamReplayStatusBarBg        = "replay-status-bar-bg"
	ParamReplayStatusBarFg        = "replay-status-bar-fg"
	ParamReplayTextCopyMode       = "replay-text-copy-mode"
	ParamReplayTextPlayMode       = "replay-text-play-mode"
	ParamReplayTextTimeMode       = "replay-text-time-mode"
	ParamReplayTextVisualMode     = "replay-text-visual-mode"
	ParamReplayTimeBg             = "replay-time-bg"
	ParamReplayTimeFg             = "replay-time-fg"
	ParamReplayVisualBg           = "replay-visual-bg"
	ParamReplayVisualFg           = "replay-visual-fg"
	ParamSearchStatusBarBg        = "search-status-bar-bg"
	ParamSearchStatusBarFg        = "search-status-bar-fg"
	ParamSearchTextNoMatchesFound = "search-text-no-matches-found"
	ParamSearchTextSearching      = "search-text-searching"
	ParamSkipInput                = "---skip-input"
	ParamTerminalTextExited       = "terminal-text-exited"
	ParamTimestampFormat          = "timestamp-format"
	ParamUseSystemClipboard       = "use-system-clipboard"
)

func (p *Parameters) Animate() bool {
	value, ok := p.Get(ParamAnimate)
	if !ok {
		return defaults.Animate
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.Animate
	}

	return realValue
}

func (p *Parameters) SetAnimate(value bool) {
	p.set(ParamAnimate, value)
}

func (p *Parameters) Animations() []string {
	value, ok := p.Get(ParamAnimations)
	if !ok {
		return defaults.Animations
	}

	realValue, ok := value.([]string)
	if !ok {
		return defaults.Animations
	}

	return realValue
}

func (p *Parameters) SetAnimations(value []string) {
	p.set(ParamAnimations, value)
}

func (p *Parameters) ColorError() *style.Color {
	value, ok := p.Get(ParamColorError)
	if !ok {
		return defaults.ColorError
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ColorError
	}

	return realValue
}

func (p *Parameters) SetColorError(value *style.Color) {
	p.set(ParamColorError, value)
}

func (p *Parameters) ColorInfo() *style.Color {
	value, ok := p.Get(ParamColorInfo)
	if !ok {
		return defaults.ColorInfo
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ColorInfo
	}

	return realValue
}

func (p *Parameters) SetColorInfo(value *style.Color) {
	p.set(ParamColorInfo, value)
}

func (p *Parameters) ColorMap() *style.ColorMap {
	value, ok := p.Get(ParamColorMap)
	if !ok {
		return defaults.ColorMap
	}

	realValue, ok := value.(*style.ColorMap)
	if !ok {
		return defaults.ColorMap
	}

	return realValue
}

func (p *Parameters) SetColorMap(value *style.ColorMap) {
	p.set(ParamColorMap, value)
}

func (p *Parameters) ColorWarn() *style.Color {
	value, ok := p.Get(ParamColorWarn)
	if !ok {
		return defaults.ColorWarn
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ColorWarn
	}

	return realValue
}

func (p *Parameters) SetColorWarn(value *style.Color) {
	p.set(ParamColorWarn, value)
}

func (p *Parameters) DataDirectory() string {
	value, ok := p.Get(ParamDataDirectory)
	if !ok {
		return defaults.DataDirectory
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.DataDirectory
	}

	return realValue
}

func (p *Parameters) SetDataDirectory(value string) {
	p.set(ParamDataDirectory, value)
}

func (p *Parameters) DefaultFrame() string {
	value, ok := p.Get(ParamDefaultFrame)
	if !ok {
		return defaults.DefaultFrame
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.DefaultFrame
	}

	return realValue
}

func (p *Parameters) SetDefaultFrame(value string) {
	p.set(ParamDefaultFrame, value)
}

func (p *Parameters) DefaultShell() string {
	value, ok := p.Get(ParamDefaultShell)
	if !ok {
		return defaults.DefaultShell
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.DefaultShell
	}

	return realValue
}

func (p *Parameters) SetDefaultShell(value string) {
	p.set(ParamDefaultShell, value)
}

func (p *Parameters) InputFindActiveBg() *style.Color {
	value, ok := p.Get(ParamInputFindActiveBg)
	if !ok {
		return defaults.InputFindActiveBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputFindActiveBg
	}

	return realValue
}

func (p *Parameters) SetInputFindActiveBg(value *style.Color) {
	p.set(ParamInputFindActiveBg, value)
}

func (p *Parameters) InputFindActiveFg() *style.Color {
	value, ok := p.Get(ParamInputFindActiveFg)
	if !ok {
		return defaults.InputFindActiveFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputFindActiveFg
	}

	return realValue
}

func (p *Parameters) SetInputFindActiveFg(value *style.Color) {
	p.set(ParamInputFindActiveFg, value)
}

func (p *Parameters) InputFindHighlightBg() *style.Color {
	value, ok := p.Get(ParamInputFindHighlightBg)
	if !ok {
		return defaults.InputFindHighlightBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputFindHighlightBg
	}

	return realValue
}

func (p *Parameters) SetInputFindHighlightBg(value *style.Color) {
	p.set(ParamInputFindHighlightBg, value)
}

func (p *Parameters) InputFindHighlightFg() *style.Color {
	value, ok := p.Get(ParamInputFindHighlightFg)
	if !ok {
		return defaults.InputFindHighlightFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputFindHighlightFg
	}

	return realValue
}

func (p *Parameters) SetInputFindHighlightFg(value *style.Color) {
	p.set(ParamInputFindHighlightFg, value)
}

func (p *Parameters) InputFindInactiveBg() *style.Color {
	value, ok := p.Get(ParamInputFindInactiveBg)
	if !ok {
		return defaults.InputFindInactiveBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputFindInactiveBg
	}

	return realValue
}

func (p *Parameters) SetInputFindInactiveBg(value *style.Color) {
	p.set(ParamInputFindInactiveBg, value)
}

func (p *Parameters) InputFindInactiveFg() *style.Color {
	value, ok := p.Get(ParamInputFindInactiveFg)
	if !ok {
		return defaults.InputFindInactiveFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputFindInactiveFg
	}

	return realValue
}

func (p *Parameters) SetInputFindInactiveFg(value *style.Color) {
	p.set(ParamInputFindInactiveFg, value)
}

func (p *Parameters) InputPreviewBorder() *style.Border {
	value, ok := p.Get(ParamInputPreviewBorder)
	if !ok {
		return defaults.InputPreviewBorder
	}

	realValue, ok := value.(*style.Border)
	if !ok {
		return defaults.InputPreviewBorder
	}

	return realValue
}

func (p *Parameters) SetInputPreviewBorder(value *style.Border) {
	p.set(ParamInputPreviewBorder, value)
}

func (p *Parameters) InputPreviewBorderFg() *style.Color {
	value, ok := p.Get(ParamInputPreviewBorderFg)
	if !ok {
		return defaults.InputPreviewBorderFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputPreviewBorderFg
	}

	return realValue
}

func (p *Parameters) SetInputPreviewBorderFg(value *style.Color) {
	p.set(ParamInputPreviewBorderFg, value)
}

func (p *Parameters) InputPromptBg() *style.Color {
	value, ok := p.Get(ParamInputPromptBg)
	if !ok {
		return defaults.InputPromptBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputPromptBg
	}

	return realValue
}

func (p *Parameters) SetInputPromptBg(value *style.Color) {
	p.set(ParamInputPromptBg, value)
}

func (p *Parameters) InputPromptFg() *style.Color {
	value, ok := p.Get(ParamInputPromptFg)
	if !ok {
		return defaults.InputPromptFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputPromptFg
	}

	return realValue
}

func (p *Parameters) SetInputPromptFg(value *style.Color) {
	p.set(ParamInputPromptFg, value)
}

func (p *Parameters) InputThumbsHintBg() *style.Color {
	value, ok := p.Get(ParamInputThumbsHintBg)
	if !ok {
		return defaults.InputThumbsHintBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputThumbsHintBg
	}

	return realValue
}

func (p *Parameters) SetInputThumbsHintBg(value *style.Color) {
	p.set(ParamInputThumbsHintBg, value)
}

func (p *Parameters) InputThumbsHintFg() *style.Color {
	value, ok := p.Get(ParamInputThumbsHintFg)
	if !ok {
		return defaults.InputThumbsHintFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputThumbsHintFg
	}

	return realValue
}

func (p *Parameters) SetInputThumbsHintFg(value *style.Color) {
	p.set(ParamInputThumbsHintFg, value)
}

func (p *Parameters) InputThumbsMatchBg() *style.Color {
	value, ok := p.Get(ParamInputThumbsMatchBg)
	if !ok {
		return defaults.InputThumbsMatchBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputThumbsMatchBg
	}

	return realValue
}

func (p *Parameters) SetInputThumbsMatchBg(value *style.Color) {
	p.set(ParamInputThumbsMatchBg, value)
}

func (p *Parameters) InputThumbsMatchFg() *style.Color {
	value, ok := p.Get(ParamInputThumbsMatchFg)
	if !ok {
		return defaults.InputThumbsMatchFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputThumbsMatchFg
	}

	return realValue
}

func (p *Parameters) SetInputThumbsMatchFg(value *style.Color) {
	p.set(ParamInputThumbsMatchFg, value)
}

func (p *Parameters) InputThumbsPartialBg() *style.Color {
	value, ok := p.Get(ParamInputThumbsPartialBg)
	if !ok {
		return defaults.InputThumbsPartialBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputThumbsPartialBg
	}

	return realValue
}

func (p *Parameters) SetInputThumbsPartialBg(value *style.Color) {
	p.set(ParamInputThumbsPartialBg, value)
}

func (p *Parameters) InputThumbsPartialFg() *style.Color {
	value, ok := p.Get(ParamInputThumbsPartialFg)
	if !ok {
		return defaults.InputThumbsPartialFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.InputThumbsPartialFg
	}

	return realValue
}

func (p *Parameters) SetInputThumbsPartialFg(value *style.Color) {
	p.set(ParamInputThumbsPartialFg, value)
}

func (p *Parameters) NumSearchWorkers() int {
	value, ok := p.Get(ParamNumSearchWorkers)
	if !ok {
		return defaults.NumSearchWorkers
	}

	realValue, ok := value.(int)
	if !ok {
		return defaults.NumSearchWorkers
	}

	return realValue
}

func (p *Parameters) SetNumSearchWorkers(value int) {
	p.set(ParamNumSearchWorkers, value)
}

func (p *Parameters) RemovePaneOnExit() bool {
	value, ok := p.Get(ParamRemovePaneOnExit)
	if !ok {
		return defaults.RemovePaneOnExit
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.RemovePaneOnExit
	}

	return realValue
}

func (p *Parameters) SetRemovePaneOnExit(value bool) {
	p.set(ParamRemovePaneOnExit, value)
}

func (p *Parameters) ReplayCopyBg() *style.Color {
	value, ok := p.Get(ParamReplayCopyBg)
	if !ok {
		return defaults.ReplayCopyBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayCopyBg
	}

	return realValue
}

func (p *Parameters) SetReplayCopyBg(value *style.Color) {
	p.set(ParamReplayCopyBg, value)
}

func (p *Parameters) ReplayCopyFg() *style.Color {
	value, ok := p.Get(ParamReplayCopyFg)
	if !ok {
		return defaults.ReplayCopyFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayCopyFg
	}

	return realValue
}

func (p *Parameters) SetReplayCopyFg(value *style.Color) {
	p.set(ParamReplayCopyFg, value)
}

func (p *Parameters) ReplayIncrementalBg() *style.Color {
	value, ok := p.Get(ParamReplayIncrementalBg)
	if !ok {
		return defaults.ReplayIncrementalBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayIncrementalBg
	}

	return realValue
}

func (p *Parameters) SetReplayIncrementalBg(value *style.Color) {
	p.set(ParamReplayIncrementalBg, value)
}

func (p *Parameters) ReplayIncrementalFg() *style.Color {
	value, ok := p.Get(ParamReplayIncrementalFg)
	if !ok {
		return defaults.ReplayIncrementalFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayIncrementalFg
	}

	return realValue
}

func (p *Parameters) SetReplayIncrementalFg(value *style.Color) {
	p.set(ParamReplayIncrementalFg, value)
}

func (p *Parameters) ReplayMatchActiveBg() *style.Color {
	value, ok := p.Get(ParamReplayMatchActiveBg)
	if !ok {
		return defaults.ReplayMatchActiveBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayMatchActiveBg
	}

	return realValue
}

func (p *Parameters) SetReplayMatchActiveBg(value *style.Color) {
	p.set(ParamReplayMatchActiveBg, value)
}

func (p *Parameters) ReplayMatchActiveFg() *style.Color {
	value, ok := p.Get(ParamReplayMatchActiveFg)
	if !ok {
		return defaults.ReplayMatchActiveFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayMatchActiveFg
	}

	return realValue
}

func (p *Parameters) SetReplayMatchActiveFg(value *style.Color) {
	p.set(ParamReplayMatchActiveFg, value)
}

func (p *Parameters) ReplayMatchInactiveBg() *style.Color {
	value, ok := p.Get(ParamReplayMatchInactiveBg)
	if !ok {
		return defaults.ReplayMatchInactiveBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayMatchInactiveBg
	}

	return realValue
}

func (p *Parameters) SetReplayMatchInactiveBg(value *style.Color) {
	p.set(ParamReplayMatchInactiveBg, value)
}

func (p *Parameters) ReplayMatchInactiveFg() *style.Color {
	value, ok := p.Get(ParamReplayMatchInactiveFg)
	if !ok {
		return defaults.ReplayMatchInactiveFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayMatchInactiveFg
	}

	return realValue
}

func (p *Parameters) SetReplayMatchInactiveFg(value *style.Color) {
	p.set(ParamReplayMatchInactiveFg, value)
}

func (p *Parameters) ReplayPlayBg() *style.Color {
	value, ok := p.Get(ParamReplayPlayBg)
	if !ok {
		return defaults.ReplayPlayBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayPlayBg
	}

	return realValue
}

func (p *Parameters) SetReplayPlayBg(value *style.Color) {
	p.set(ParamReplayPlayBg, value)
}

func (p *Parameters) ReplayPlayFg() *style.Color {
	value, ok := p.Get(ParamReplayPlayFg)
	if !ok {
		return defaults.ReplayPlayFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayPlayFg
	}

	return realValue
}

func (p *Parameters) SetReplayPlayFg(value *style.Color) {
	p.set(ParamReplayPlayFg, value)
}

func (p *Parameters) ReplaySelectionBg() *style.Color {
	value, ok := p.Get(ParamReplaySelectionBg)
	if !ok {
		return defaults.ReplaySelectionBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplaySelectionBg
	}

	return realValue
}

func (p *Parameters) SetReplaySelectionBg(value *style.Color) {
	p.set(ParamReplaySelectionBg, value)
}

func (p *Parameters) ReplaySelectionFg() *style.Color {
	value, ok := p.Get(ParamReplaySelectionFg)
	if !ok {
		return defaults.ReplaySelectionFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplaySelectionFg
	}

	return realValue
}

func (p *Parameters) SetReplaySelectionFg(value *style.Color) {
	p.set(ParamReplaySelectionFg, value)
}

func (p *Parameters) ReplayStatusBarBg() *style.Color {
	value, ok := p.Get(ParamReplayStatusBarBg)
	if !ok {
		return defaults.ReplayStatusBarBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayStatusBarBg
	}

	return realValue
}

func (p *Parameters) SetReplayStatusBarBg(value *style.Color) {
	p.set(ParamReplayStatusBarBg, value)
}

func (p *Parameters) ReplayStatusBarFg() *style.Color {
	value, ok := p.Get(ParamReplayStatusBarFg)
	if !ok {
		return defaults.ReplayStatusBarFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayStatusBarFg
	}

	return realValue
}

func (p *Parameters) SetReplayStatusBarFg(value *style.Color) {
	p.set(ParamReplayStatusBarFg, value)
}

func (p *Parameters) ReplayTextCopyMode() string {
	value, ok := p.Get(ParamReplayTextCopyMode)
	if !ok {
		return defaults.ReplayTextCopyMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextCopyMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextCopyMode(value string) {
	p.set(ParamReplayTextCopyMode, value)
}

func (p *Parameters) ReplayTextPlayMode() string {
	value, ok := p.Get(ParamReplayTextPlayMode)
	if !ok {
		return defaults.ReplayTextPlayMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextPlayMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextPlayMode(value string) {
	p.set(ParamReplayTextPlayMode, value)
}

func (p *Parameters) ReplayTextTimeMode() string {
	value, ok := p.Get(ParamReplayTextTimeMode)
	if !ok {
		return defaults.ReplayTextTimeMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextTimeMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextTimeMode(value string) {
	p.set(ParamReplayTextTimeMode, value)
}

func (p *Parameters) ReplayTextVisualMode() string {
	value, ok := p.Get(ParamReplayTextVisualMode)
	if !ok {
		return defaults.ReplayTextVisualMode
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.ReplayTextVisualMode
	}

	return realValue
}

func (p *Parameters) SetReplayTextVisualMode(value string) {
	p.set(ParamReplayTextVisualMode, value)
}

func (p *Parameters) ReplayTimeBg() *style.Color {
	value, ok := p.Get(ParamReplayTimeBg)
	if !ok {
		return defaults.ReplayTimeBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayTimeBg
	}

	return realValue
}

func (p *Parameters) SetReplayTimeBg(value *style.Color) {
	p.set(ParamReplayTimeBg, value)
}

func (p *Parameters) ReplayTimeFg() *style.Color {
	value, ok := p.Get(ParamReplayTimeFg)
	if !ok {
		return defaults.ReplayTimeFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayTimeFg
	}

	return realValue
}

func (p *Parameters) SetReplayTimeFg(value *style.Color) {
	p.set(ParamReplayTimeFg, value)
}

func (p *Parameters) ReplayVisualBg() *style.Color {
	value, ok := p.Get(ParamReplayVisualBg)
	if !ok {
		return defaults.ReplayVisualBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayVisualBg
	}

	return realValue
}

func (p *Parameters) SetReplayVisualBg(value *style.Color) {
	p.set(ParamReplayVisualBg, value)
}

func (p *Parameters) ReplayVisualFg() *style.Color {
	value, ok := p.Get(ParamReplayVisualFg)
	if !ok {
		return defaults.ReplayVisualFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.ReplayVisualFg
	}

	return realValue
}

func (p *Parameters) SetReplayVisualFg(value *style.Color) {
	p.set(ParamReplayVisualFg, value)
}

func (p *Parameters) SearchStatusBarBg() *style.Color {
	value, ok := p.Get(ParamSearchStatusBarBg)
	if !ok {
		return defaults.SearchStatusBarBg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.SearchStatusBarBg
	}

	return realValue
}

func (p *Parameters) SetSearchStatusBarBg(value *style.Color) {
	p.set(ParamSearchStatusBarBg, value)
}

func (p *Parameters) SearchStatusBarFg() *style.Color {
	value, ok := p.Get(ParamSearchStatusBarFg)
	if !ok {
		return defaults.SearchStatusBarFg
	}

	realValue, ok := value.(*style.Color)
	if !ok {
		return defaults.SearchStatusBarFg
	}

	return realValue
}

func (p *Parameters) SetSearchStatusBarFg(value *style.Color) {
	p.set(ParamSearchStatusBarFg, value)
}

func (p *Parameters) SearchTextNoMatchesFound() string {
	value, ok := p.Get(ParamSearchTextNoMatchesFound)
	if !ok {
		return defaults.SearchTextNoMatchesFound
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.SearchTextNoMatchesFound
	}

	return realValue
}

func (p *Parameters) SetSearchTextNoMatchesFound(value string) {
	p.set(ParamSearchTextNoMatchesFound, value)
}

func (p *Parameters) SearchTextSearching() string {
	value, ok := p.Get(ParamSearchTextSearching)
	if !ok {
		return defaults.SearchTextSearching
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.SearchTextSearching
	}

	return realValue
}

func (p *Parameters) SetSearchTextSearching(value string) {
	p.set(ParamSearchTextSearching, value)
}

func (p *Parameters) SkipInput() bool {
	value, ok := p.Get(ParamSkipInput)
	if !ok {
		return defaults.skipInput
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.skipInput
	}

	return realValue
}

func (p *Parameters) SetSkipInput(value bool) {
	p.set(ParamSkipInput, value)
}

func (p *Parameters) TerminalTextExited() string {
	value, ok := p.Get(ParamTerminalTextExited)
	if !ok {
		return defaults.TerminalTextExited
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.TerminalTextExited
	}

	return realValue
}

func (p *Parameters) SetTerminalTextExited(value string) {
	p.set(ParamTerminalTextExited, value)
}

func (p *Parameters) TimestampFormat() string {
	value, ok := p.Get(ParamTimestampFormat)
	if !ok {
		return defaults.TimestampFormat
	}

	realValue, ok := value.(string)
	if !ok {
		return defaults.TimestampFormat
	}

	return realValue
}

func (p *Parameters) SetTimestampFormat(value string) {
	p.set(ParamTimestampFormat, value)
}

func (p *Parameters) UseSystemClipboard() bool {
	value, ok := p.Get(ParamUseSystemClipboard)
	if !ok {
		return defaults.UseSystemClipboard
	}

	realValue, ok := value.(bool)
	if !ok {
		return defaults.UseSystemClipboard
	}

	return realValue
}

func (p *Parameters) SetUseSystemClipboard(value bool) {
	p.set(ParamUseSystemClipboard, value)
}

func (p *Parameters) isDefault(key string) bool {
	switch key {
	case ParamAnimate:
		return true
	case ParamAnimations:
		return true
	case ParamColorError:
		return true
	case ParamColorInfo:
		return true
	case ParamColorMap:
		return true
	case ParamColorWarn:
		return true
	case ParamDataDirectory:
		return true
	case ParamDefaultFrame:
		return true
	case ParamDefaultShell:
		return true
	case ParamInputFindActiveBg:
		return true
	case ParamInputFindActiveFg:
		return true
	case ParamInputFindHighlightBg:
		return true
	case ParamInputFindHighlightFg:
		return true
	case ParamInputFindInactiveBg:
		return true
	case ParamInputFindInactiveFg:
		return true
	case ParamInputPreviewBorder:
		return true
	case ParamInputPreviewBorderFg:
		return true
	case ParamInputPromptBg:
		return true
	case ParamInputPromptFg:
		return true
	case ParamInputThumbsHintBg:
		return true
	case ParamInputThumbsHintFg:
		return true
	case ParamInputThumbsMatchBg:
		return true
	case ParamInputThumbsMatchFg:
		return true
	case ParamInputThumbsPartialBg:
		return true
	case ParamInputThumbsPartialFg:
		return true
	case ParamNumSearchWorkers:
		return true
	case ParamRemovePaneOnExit:
		return true
	case ParamReplayCopyBg:
		return true
	case ParamReplayCopyFg:
		return true
	case ParamReplayIncrementalBg:
		return true
	case ParamReplayIncrementalFg:
		return true
	case ParamReplayMatchActiveBg:
		return true
	case ParamReplayMatchActiveFg:
		return true
	case ParamReplayMatchInactiveBg:
		return true
	case ParamReplayMatchInactiveFg:
		return true
	case ParamReplayPlayBg:
		return true
	case ParamReplayPlayFg:
		return true
	case ParamReplaySelectionBg:
		return true
	case ParamReplaySelectionFg:
		return true
	case ParamReplayStatusBarBg:
		return true
	case ParamReplayStatusBarFg:
		return true
	case ParamReplayTextCopyMode:
		return true
	case ParamReplayTextPlayMode:
		return true
	case ParamReplayTextTimeMode:
		return true
	case ParamReplayTextVisualMode:
		return true
	case ParamReplayTimeBg:
		return true
	case ParamReplayTimeFg:
		return true
	case ParamReplayVisualBg:
		return true
	case ParamReplayVisualFg:
		return true
	case ParamSearchStatusBarBg:
		return true
	case ParamSearchStatusBarFg:
		return true
	case ParamSearchTextNoMatchesFound:
		return true
	case ParamSearchTextSearching:
		return true
	case ParamSkipInput:
		return true
	case ParamTerminalTextExited:
		return true
	case ParamTimestampFormat:
		return true
	case ParamUseSystemClipboard:
		return true

	}
	return false
}

func (p *Parameters) getDefault(key string) (value interface{}, ok bool) {
	switch key {
	case ParamAnimate:
		return defaults.Animate, true
	case ParamAnimations:
		return defaults.Animations, true
	case ParamColorError:
		return defaults.ColorError, true
	case ParamColorInfo:
		return defaults.ColorInfo, true
	case ParamColorMap:
		return defaults.ColorMap, true
	case ParamColorWarn:
		return defaults.ColorWarn, true
	case ParamDataDirectory:
		return defaults.DataDirectory, true
	case ParamDefaultFrame:
		return defaults.DefaultFrame, true
	case ParamDefaultShell:
		return defaults.DefaultShell, true
	case ParamInputFindActiveBg:
		return defaults.InputFindActiveBg, true
	case ParamInputFindActiveFg:
		return defaults.InputFindActiveFg, true
	case ParamInputFindHighlightBg:
		return defaults.InputFindHighlightBg, true
	case ParamInputFindHighlightFg:
		return defaults.InputFindHighlightFg, true
	case ParamInputFindInactiveBg:
		return defaults.InputFindInactiveBg, true
	case ParamInputFindInactiveFg:
		return defaults.InputFindInactiveFg, true
	case ParamInputPreviewBorder:
		return defaults.InputPreviewBorder, true
	case ParamInputPreviewBorderFg:
		return defaults.InputPreviewBorderFg, true
	case ParamInputPromptBg:
		return defaults.InputPromptBg, true
	case ParamInputPromptFg:
		return defaults.InputPromptFg, true
	case ParamInputThumbsHintBg:
		return defaults.InputThumbsHintBg, true
	case ParamInputThumbsHintFg:
		return defaults.InputThumbsHintFg, true
	case ParamInputThumbsMatchBg:
		return defaults.InputThumbsMatchBg, true
	case ParamInputThumbsMatchFg:
		return defaults.InputThumbsMatchFg, true
	case ParamInputThumbsPartialBg:
		return defaults.InputThumbsPartialBg, true
	case ParamInputThumbsPartialFg:
		return defaults.InputThumbsPartialFg, true
	case ParamNumSearchWorkers:
		return defaults.NumSearchWorkers, true
	case ParamRemovePaneOnExit:
		return defaults.RemovePaneOnExit, true
	case ParamReplayCopyBg:
		return defaults.ReplayCopyBg, true
	case ParamReplayCopyFg:
		return defaults.ReplayCopyFg, true
	case ParamReplayIncrementalBg:
		return defaults.ReplayIncrementalBg, true
	case ParamReplayIncrementalFg:
		return defaults.ReplayIncrementalFg, true
	case ParamReplayMatchActiveBg:
		return defaults.ReplayMatchActiveBg, true
	case ParamReplayMatchActiveFg:
		return defaults.ReplayMatchActiveFg, true
	case ParamReplayMatchInactiveBg:
		return defaults.ReplayMatchInactiveBg, true
	case ParamReplayMatchInactiveFg:
		return defaults.ReplayMatchInactiveFg, true
	case ParamReplayPlayBg:
		return defaults.ReplayPlayBg, true
	case ParamReplayPlayFg:
		return defaults.ReplayPlayFg, true
	case ParamReplaySelectionBg:
		return defaults.ReplaySelectionBg, true
	case ParamReplaySelectionFg:
		return defaults.ReplaySelectionFg, true
	case ParamReplayStatusBarBg:
		return defaults.ReplayStatusBarBg, true
	case ParamReplayStatusBarFg:
		return defaults.ReplayStatusBarFg, true
	case ParamReplayTextCopyMode:
		return defaults.ReplayTextCopyMode, true
	case ParamReplayTextPlayMode:
		return defaults.ReplayTextPlayMode, true
	case ParamReplayTextTimeMode:
		return defaults.ReplayTextTimeMode, true
	case ParamReplayTextVisualMode:
		return defaults.ReplayTextVisualMode, true
	case ParamReplayTimeBg:
		return defaults.ReplayTimeBg, true
	case ParamReplayTimeFg:
		return defaults.ReplayTimeFg, true
	case ParamReplayVisualBg:
		return defaults.ReplayVisualBg, true
	case ParamReplayVisualFg:
		return defaults.ReplayVisualFg, true
	case ParamSearchStatusBarBg:
		return defaults.SearchStatusBarBg, true
	case ParamSearchStatusBarFg:
		return defaults.SearchStatusBarFg, true
	case ParamSearchTextNoMatchesFound:
		return defaults.SearchTextNoMatchesFound, true
	case ParamSearchTextSearching:
		return defaults.SearchTextSearching, true
	case ParamSkipInput:
		return defaults.skipInput, true
	case ParamTerminalTextExited:
		return defaults.TerminalTextExited, true
	case ParamTimestampFormat:
		return defaults.TimestampFormat, true
	case ParamUseSystemClipboard:
		return defaults.UseSystemClipboard, true

	}
	return nil, false
}

func (p *Parameters) setDefault(key string, value interface{}) error {
	janetValue, janetOk := value.(*janet.Value)
	switch key {
	case ParamAnimate:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamAnimate, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		var translated bool
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :animate: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamAnimations:
		if !janetOk {
			realValue, ok := value.([]string)
			if !ok {
				return fmt.Errorf("invalid value for ParamAnimations, should be []string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated []string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :animations: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorError:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorError, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-error: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorInfo:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorInfo, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-info: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorMap:
		if !janetOk {
			realValue, ok := value.(*style.ColorMap)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorMap, should be *style.ColorMap")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.ColorMap
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-map: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamColorWarn:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamColorWarn, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :color-warn: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamDataDirectory:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamDataDirectory, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :data-directory: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamDefaultFrame:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamDefaultFrame, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :default-frame: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamDefaultShell:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamDefaultShell, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :default-shell: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindActiveBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindActiveBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-active-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindActiveFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindActiveFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-active-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindHighlightBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindHighlightBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-highlight-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindHighlightFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindHighlightFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-highlight-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindInactiveBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindInactiveBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-inactive-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputFindInactiveFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputFindInactiveFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-find-inactive-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputPreviewBorder:
		if !janetOk {
			realValue, ok := value.(*style.Border)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputPreviewBorder, should be *style.Border")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Border
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-preview-border: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputPreviewBorderFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputPreviewBorderFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-preview-border-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputPromptBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputPromptBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-prompt-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputPromptFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputPromptFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-prompt-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsHintBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsHintBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-hint-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsHintFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsHintFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-hint-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsMatchBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsMatchBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-match-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsMatchFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsMatchFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-match-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsPartialBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsPartialBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-partial-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamInputThumbsPartialFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamInputThumbsPartialFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :input-thumbs-partial-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamNumSearchWorkers:
		if !janetOk {
			realValue, ok := value.(int)
			if !ok {
				return fmt.Errorf("invalid value for ParamNumSearchWorkers, should be int")
			}
			p.set(key, realValue)
			return nil
		}

		var translated int
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :num-search-workers: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamRemovePaneOnExit:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamRemovePaneOnExit, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		var translated bool
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :remove-pane-on-exit: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayCopyBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayCopyBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-copy-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayCopyFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayCopyFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-copy-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayIncrementalBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayIncrementalBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-incremental-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayIncrementalFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayIncrementalFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-incremental-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayMatchActiveBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayMatchActiveBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-match-active-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayMatchActiveFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayMatchActiveFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-match-active-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayMatchInactiveBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayMatchInactiveBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-match-inactive-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayMatchInactiveFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayMatchInactiveFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-match-inactive-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayPlayBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayPlayBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-play-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayPlayFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayPlayFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-play-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplaySelectionBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplaySelectionBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-selection-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplaySelectionFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplaySelectionFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-selection-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayStatusBarBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayStatusBarBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-status-bar-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayStatusBarFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayStatusBarFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-status-bar-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextCopyMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextCopyMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-copy-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextPlayMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextPlayMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-play-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextTimeMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextTimeMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-time-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTextVisualMode:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTextVisualMode, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-text-visual-mode: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTimeBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTimeBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-time-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayTimeFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayTimeFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-time-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayVisualBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayVisualBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-visual-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamReplayVisualFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamReplayVisualFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :replay-visual-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSearchStatusBarBg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamSearchStatusBarBg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :search-status-bar-bg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSearchStatusBarFg:
		if !janetOk {
			realValue, ok := value.(*style.Color)
			if !ok {
				return fmt.Errorf("invalid value for ParamSearchStatusBarFg, should be *style.Color")
			}
			p.set(key, realValue)
			return nil
		}

		var translated *style.Color
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :search-status-bar-fg: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSearchTextNoMatchesFound:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamSearchTextNoMatchesFound, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :search-text-no-matches-found: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSearchTextSearching:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamSearchTextSearching, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :search-text-searching: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamSkipInput:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamSkipInput, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		return fmt.Errorf(":---skip-input is a protected parameter")

	case ParamTerminalTextExited:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamTerminalTextExited, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :terminal-text-exited: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamTimestampFormat:
		if !janetOk {
			realValue, ok := value.(string)
			if !ok {
				return fmt.Errorf("invalid value for ParamTimestampFormat, should be string")
			}
			p.set(key, realValue)
			return nil
		}

		var translated string
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :timestamp-format: %s", err)
		}
		p.set(key, translated)
		return nil

	case ParamUseSystemClipboard:
		if !janetOk {
			realValue, ok := value.(bool)
			if !ok {
				return fmt.Errorf("invalid value for ParamUseSystemClipboard, should be bool")
			}
			p.set(key, realValue)
			return nil
		}

		var translated bool
		err := janetValue.Unmarshal(&translated)
		if err != nil {
			janetValue.Free()
			return fmt.Errorf("invalid value for :use-system-clipboard: %s", err)
		}
		p.set(key, translated)
		return nil

	}
	return nil
}

func init() {
	_defaultParams = []DefaultParam{
		{
			Name:      "animate",
			Docstring: "Whether to enable animation.",
			Default:   defaults.Animate,
		},
		{
			Name:      "animations",
			Docstring: "A list of all of the enabled animations that will be used by\n(input/find). If this is an empty array, all built-in animations\nwill be enabled.",
			Default:   defaults.Animations,
		},
		{
			Name:      "color-error",
			Docstring: "The [color](/api.md#color) used for error messages.",
			Default:   defaults.ColorError,
		},
		{
			Name:      "color-info",
			Docstring: "The [color](/api.md#color) used for info messages.",
			Default:   defaults.ColorInfo,
		},
		{
			Name:      "color-map",
			Docstring: "The [color map](/api.md#color-map) used to translate the colors\nused for rendering a pane.",
			Default:   defaults.ColorMap,
		},
		{
			Name:      "color-warn",
			Docstring: "The [color](/api.md#color) used for warning messages.",
			Default:   defaults.ColorWarn,
		},
		{
			Name:      "data-directory",
			Docstring: "The directory in which .borg files will be saved. This is [inferred\non startup](/replay-mode.md#recording-to-disk). If\nset to an empty string, recording to disk is disabled.",
			Default:   defaults.DataDirectory,
		},
		{
			Name:      "default-frame",
			Docstring: "The frame used for all new clients. A blank string means a random\nframe will be chosen from all frames.",
			Default:   defaults.DefaultFrame,
		},
		{
			Name:      "default-shell",
			Docstring: "The default shell with which to start panes. Defaults to the value\nof `$SHELL` on startup.",
			Default:   defaults.DefaultShell,
		},
		{
			Name:      "input-find-active-bg",
			Docstring: "The background [color](/api.md#color) of the active row in (input/find).",
			Default:   defaults.InputFindActiveBg,
		},
		{
			Name:      "input-find-active-fg",
			Docstring: "The foreground [color](/api.md#color) of the active row in (input/find).",
			Default:   defaults.InputFindActiveFg,
		},
		{
			Name:      "input-find-highlight-bg",
			Docstring: "The background [color](/api.md#color) of highlighted characters in (input/find).",
			Default:   defaults.InputFindHighlightBg,
		},
		{
			Name:      "input-find-highlight-fg",
			Docstring: "The foreground [color](/api.md#color) of highlighted characters in (input/find).",
			Default:   defaults.InputFindHighlightFg,
		},
		{
			Name:      "input-find-inactive-bg",
			Docstring: "The background [color](/api.md#color) of the inactive row in (input/find).",
			Default:   defaults.InputFindInactiveBg,
		},
		{
			Name:      "input-find-inactive-fg",
			Docstring: "The foreground [color](/api.md#color) of the inactive row in (input/find).",
			Default:   defaults.InputFindInactiveFg,
		},
		{
			Name:      "input-preview-border",
			Docstring: "The border style of the preview border in (input/find).",
			Default:   defaults.InputPreviewBorder,
		},
		{
			Name:      "input-preview-border-fg",
			Docstring: "The [color](/api.md#color) of the preview border in (input/find).",
			Default:   defaults.InputPreviewBorderFg,
		},
		{
			Name:      "input-prompt-bg",
			Docstring: "The background [color](/api.md#color) of the input prompt in\n(input/*) functions.",
			Default:   defaults.InputPromptBg,
		},
		{
			Name:      "input-prompt-fg",
			Docstring: "The foreground [color](/api.md#color) of the input prompt in\n(input/*) functions.",
			Default:   defaults.InputPromptFg,
		},
		{
			Name:      "input-thumbs-hint-bg",
			Docstring: "The background [color](/api.md#color) of hint text in (input/thumbs).",
			Default:   defaults.InputThumbsHintBg,
		},
		{
			Name:      "input-thumbs-hint-fg",
			Docstring: "The foreground [color](/api.md#color) of hint text in (input/thumbs).",
			Default:   defaults.InputThumbsHintFg,
		},
		{
			Name:      "input-thumbs-match-bg",
			Docstring: "The background [color](/api.md#color) of match text in (input/thumbs).",
			Default:   defaults.InputThumbsMatchBg,
		},
		{
			Name:      "input-thumbs-match-fg",
			Docstring: "The foreground [color](/api.md#color) of match text in (input/thumbs).",
			Default:   defaults.InputThumbsMatchFg,
		},
		{
			Name:      "input-thumbs-partial-bg",
			Docstring: "The background [color](/api.md#color) of partially selected hint text in (input/thumbs).",
			Default:   defaults.InputThumbsPartialBg,
		},
		{
			Name:      "input-thumbs-partial-fg",
			Docstring: "The foreground [color](/api.md#color) of partially selected hint text in (input/thumbs).",
			Default:   defaults.InputThumbsPartialFg,
		},
		{
			Name:      "num-search-workers",
			Docstring: "The number of goroutines to use for searching in .borg files.\nDefaults to the number of CPUs.",
			Default:   defaults.NumSearchWorkers,
		},
		{
			Name:      "remove-pane-on-exit",
			Docstring: "If this is `true`, when a pane's process exits or its node is killed\n(such as with {{api tree/rm}}), the portion of the layout related\nto that node will be removed. This makes cy's layout functionality\nwork a bit more like tmux.",
			Default:   defaults.RemovePaneOnExit,
		},
		{
			Name:      "replay-copy-bg",
			Docstring: "The [color](/api.md#color) used to represent copy mode.",
			Default:   defaults.ReplayCopyBg,
		},
		{
			Name:      "replay-copy-fg",
			Docstring: "The foreground [color](/api.md#color) used in time mode when the player is playing.",
			Default:   defaults.ReplayCopyFg,
		},
		{
			Name:      "replay-incremental-bg",
			Docstring: "The background [color](/api.md#color) for incremental search in replay mode.",
			Default:   defaults.ReplayIncrementalBg,
		},
		{
			Name:      "replay-incremental-fg",
			Docstring: "The foreground [color](/api.md#color) for incremental search in replay mode.",
			Default:   defaults.ReplayIncrementalFg,
		},
		{
			Name:      "replay-match-active-bg",
			Docstring: "The background [color](/api.md#color) for the current search match in replay mode.",
			Default:   defaults.ReplayMatchActiveBg,
		},
		{
			Name:      "replay-match-active-fg",
			Docstring: "The foreground [color](/api.md#color) for the current search match in replay mode.",
			Default:   defaults.ReplayMatchActiveFg,
		},
		{
			Name:      "replay-match-inactive-bg",
			Docstring: "The background [color](/api.md#color) for search matches in replay mode.",
			Default:   defaults.ReplayMatchInactiveBg,
		},
		{
			Name:      "replay-match-inactive-fg",
			Docstring: "The foreground [color](/api.md#color) for search matches in replay mode.",
			Default:   defaults.ReplayMatchInactiveFg,
		},
		{
			Name:      "replay-play-bg",
			Docstring: "The [color](/api.md#color) used in time mode when the player is playing.",
			Default:   defaults.ReplayPlayBg,
		},
		{
			Name:      "replay-play-fg",
			Docstring: "The foreground [color](/api.md#color) used in time mode when the player is playing.",
			Default:   defaults.ReplayPlayFg,
		},
		{
			Name:      "replay-selection-bg",
			Docstring: "The background [color](/api.md#color) for selections in replay mode.",
			Default:   defaults.ReplaySelectionBg,
		},
		{
			Name:      "replay-selection-fg",
			Docstring: "The foreground [color](/api.md#color) for selections in replay mode.",
			Default:   defaults.ReplaySelectionFg,
		},
		{
			Name:      "replay-status-bar-bg",
			Docstring: "The background [color](/api.md#color) of the status bar in replay mode.",
			Default:   defaults.ReplayStatusBarBg,
		},
		{
			Name:      "replay-status-bar-fg",
			Docstring: "The foreground [color](/api.md#color) of the status bar in replay mode.",
			Default:   defaults.ReplayStatusBarFg,
		},
		{
			Name:      "replay-text-copy-mode",
			Docstring: "The text shown in the status bar when in copy mode.",
			Default:   defaults.ReplayTextCopyMode,
		},
		{
			Name:      "replay-text-play-mode",
			Docstring: "The text shown in the status bar when playing.",
			Default:   defaults.ReplayTextPlayMode,
		},
		{
			Name:      "replay-text-time-mode",
			Docstring: "The text shown in the status bar when in time mode.",
			Default:   defaults.ReplayTextTimeMode,
		},
		{
			Name:      "replay-text-visual-mode",
			Docstring: "The text shown in the status bar when in visual mode.",
			Default:   defaults.ReplayTextVisualMode,
		},
		{
			Name:      "replay-time-bg",
			Docstring: "The [color](/api.md#color) used to represent time mode.",
			Default:   defaults.ReplayTimeBg,
		},
		{
			Name:      "replay-time-fg",
			Docstring: "The foreground [color](/api.md#color) used to represent time mode.",
			Default:   defaults.ReplayTimeFg,
		},
		{
			Name:      "replay-visual-bg",
			Docstring: "The [color](/api.md#color) used to represent visual mode.",
			Default:   defaults.ReplayVisualBg,
		},
		{
			Name:      "replay-visual-fg",
			Docstring: "The foreground [color](/api.md#color) used in time mode when the player is playing.",
			Default:   defaults.ReplayVisualFg,
		},
		{
			Name:      "search-status-bar-bg",
			Docstring: "The background [color](/api.md#color) of the status bar in search mode.",
			Default:   defaults.SearchStatusBarBg,
		},
		{
			Name:      "search-status-bar-fg",
			Docstring: "The foreground [color](/api.md#color) of the status bar in search mode.",
			Default:   defaults.SearchStatusBarFg,
		},
		{
			Name:      "search-text-no-matches-found",
			Docstring: "The text shown in the status bar when no matches are found.",
			Default:   defaults.SearchTextNoMatchesFound,
		},
		{
			Name:      "search-text-searching",
			Docstring: "The text shown in the status bar when searching.",
			Default:   defaults.SearchTextSearching,
		},
		{
			Name:      "terminal-text-exited",
			Docstring: "The text shown when a terminal session exits.",
			Default:   defaults.TerminalTextExited,
		},
		{
			Name:      "timestamp-format",
			Docstring: "The format for all timestamps shown in cy. This uses Go's\ntime.Layout format described\n[here](https://pkg.go.dev/time#Layout).",
			Default:   defaults.TimestampFormat,
		},
		{
			Name:      "use-system-clipboard",
			Docstring: "Whether to use the system clipboard instead of outputting OSC-52\ncodes. This should generally be \"true\" unless you use an old terminal\nemulator.",
			Default:   defaults.UseSystemClipboard,
		},
	}
}
